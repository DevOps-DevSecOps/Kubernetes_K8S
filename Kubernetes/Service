[Services]
The each Pod has its own IP address.
Pods are ephemeral because are destory frequently when Pods delete OR terminated, recreating the new pods with existing YAML template OR command line interface.
So the Pod IP address are frequently keep on changing.
Service selector matches a Pod label (OR) If the Label/Selector then Pod and Service match.
But the Service will maintain the stable static IP address to connect a set/group of pods in a cluster.

[ServiceTypes]
Kubernetes ServiceTypes allow you to specify what kind of Service you want.
● ClusterIP
The ClusterIP is the default for the service.
This type makes the Service only reachable from with in the cluster via a cluster-internal IP..
It exposes the Pod to only within the cluster.
It assigns a private IP address in ClusterIP range.
It can talk to applications only with in the cluster.
So the Pods can reach the service on apps port number.
It exposes the service on an internal IP in the cluster.
It exposes a service which is only accessible from within the cluster.
By default Kubernetes services are accessible at the ClusterIP which is an internal IP address reachable from inside of the Kubernetes cluster only.
There are two ways to assign a virtual IP address for a Service.
* dynamically
The cluster control plane automatically picks a free IP address from within the configured IP range for "type: ClusterIP" Service.
* statically
So manually specify an IP address of choice, from within the configured IP range for Service.
● NodePort
A port that is the same on each node that is also reachable externally outside.
It exposes the Pod to outside the cluster.
It assigns a port on the worker nodes to expose it outside the cluster.
It exposes a service via a static port on each node’s IP.
Port is open on every node IP.
It exposes a port named NodePort on all worker nodes.
It exposes the service on the same port of each selected Node in the cluster.
Make the service accessible from outside the cluster using "NODE_PUBLIC_IP_ADDRESS:NODE_PORT_NO".
This type of service makes it possible to access a Service by directing requests to a specific port on every Node, accessed via the NodeIP (Kubernetes automatically creates a ClusterIP service to route the request). 
To make the service accessible from outside of the cluster a user can create a service of type NodePort.
When creating a NodePort service, the user can specify a port from the range 30000-32767, and each Kubernetes node will proxy that port to the pods selected by the service.
The nodePort is dynamically OR randomly took the port number range between 30000 to 32767 by default.
But can also assign statically OR particular specific custom port number.
● LoadBalancer
It created by the cloud provider that will route external traffic to every node on the NodePort (ELB on AWS).
It exposes the Pod to outside the cluster.
It create a LoadBalancer in cloud.
It exposes the service via the cloud provider’s load balancer.
LoadBalancer builds on NodePort and create an external load-balancer in cloud such as AWS, Azure, GCP.
● ExternalName
It can provide a DNS name for the service.
This only works when the DNS add-on is enabled.
It add CNAME DNS record to coreDNS.
This type of service were used to maps the service to a CNAME record such as a Fully Qualified Domain Name.
This Service type uses DNS in place of a selector and creates an internal CNAME DNS entry that aliases another.

[Headless]
It allows direct connection to a Pod. So it won't take any support in ServiceTypes. 
The client/user wants to communicate with one specific Pod directly.
Pods want to talk directly with specific Pod.
So not randomly selected, mostly it will be used in Stateful applications like Databases.
Headless Service mostly will be used in Databases. The below diagram will be example to understand.
                    POD_MySQL-0                                              POD_MySQL-1
                     (master)                                                 (worker)
                       |  |                                                     |  |
                       |  |                                                     |  |
              writing  |  |  reading <-- continuous syncronization --> reading  |  |  reading
                                              (data replicas)
Only master is allowed to write to Database (DB).

{Port in YAML}
● targetPort
The 'targetPort' will be connect to the Pod Container port number.
This port on the pod that the request get sent to that pod will be listening on.
So application in the container will needs to be listening for network requests on this port for the service. 
● port
The 'port' will be connect to the 'targetPort' to the Pod Container port number.
It exposes the service on the specific port internally with in the cluster.
So other pods with in the cluster can communicate with this server on the specific port.
● nodePort
It exposes the service externally visible outside the cluster by node public ip address and node port no. The service also has to be of type NodePort.

[hostPort]
The hostPort setting applies to the Kubernetes containers.
The container port will be exposed to the external network at <hostIP>:<hostPort>, where the hostIP is the IP address of the Kubernetes node where the container is running and the hostPort is the port requested by the user.
The hostPort feature allows to expose a single container port on the host IP.
Using the hostPort to expose an application to the outside of the Kubernetes cluster.
The host IP can change when the container is restarted, two containers using the same hostPort cannot be scheduled on the same node.

[hostNetwork]
When a pod is configured with "hostNetwork: true", the applications running in such a pod can directly see the network interfaces of the host machine where the pod was started.
An application that is configured to listen on all network interfaces will in turn be accessible on all network interfaces of the host machine.
The every time the pod is restarted Kubernetes can reschedule the pod onto a different node and so the application will change its IP address.
Besides that two applications requiring the same port cannot run on the same node. 
This can lead to port conflicts when the number of applications running on the cluster grows.

[Endpoints]
Service selector matches a pod label, Kubernetes will automatically create an Endpoints object with the same name as the service, which stores the pod’s IP address and port.
When the service receives a request, its proxy will redirect it to one of those IPs and ports.
Kubernetes will automatically update the endpoint resource IPs in case of editing or scaling of a deployment in which pods are already linked to a service.
If create a service without specifying a pod selector, Kubernetes will not generate the endpoint resource and it will be up to create one with the endpoints to link to the service.

[IPs and Ports]
● Pod IP
In the Pod Container inside the port number of an application.
In a Service the 'targetPort' will connect to the Pod Container port number.
$ curl http://POD_IP_ADDRESS:POD_CONTAINER_PORT_NO
The above command will only work with in the Pod.
● Service IP
In a Service the 'port' will connect to the 'targetPort' to the Pod Container port number.
$ curl http://CLUSTER_IP_ADDRESS:SERVICE_PORT_NO
$ curl http://CLUSTER_IP_ADDRESS:CLUSTER_PORT_NO
The above command will only work with in the Cluster.
The "--port=SERVICE_PORT_NO" mean that "--port=CLUSTER_PORT_NO".
● Node IP
If need to access the application from outside then need a "NODE_PUBLIC_IP_ADDRESS:NODE_PORT_NO".
$ curl http://NODE_PUBLIC_IP_ADDRESS:NODE_PORT_NO
The above command will work to access inside and outside of the cluster.
